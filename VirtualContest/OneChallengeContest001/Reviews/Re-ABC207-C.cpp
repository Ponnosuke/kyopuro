/*
    quoted from  "https://blog.hamayanhamayan.com/entry/2021/06/27/005603" written by hamayanhamayan
    

    区間をすべて[l,r)の半開区間に変換して比較をしよう。

    [l,r] -> [l,r + 0.5)
    [l,r) -> [l,r)
    (l,r] -> [l + 0.5, r + 0.5)
    (l,r) -> [l + 0.5, r)

    という風に中間をうまく利用することで区間を変換していく。
    だが、これだと小数が入ってしまうので、すべての座標を2倍にして考えることにする。
    今回考慮されるのは包含関係であり、すべての座標を2倍にしても包含関係には影響しない。
    なので、以下のように変換する

    [l,r] -> [2l,2r + 1)
    [l,r) -> [2l,2r)
    (l,r] -> [2l + 1, 2r + 1)
    (l,r) -> [2l + 1, 2r)

    これですべて同じ様式の区間になったので、全ての(i,j)の組について包含関係を判定して、
    包含しているならカウントしていけばいい。
    [a,b)と[c,d)を合成した区間は[max(a,c), min(b,d))となるので、このルールで合成して、
    要素が存在する、つまり、max(a,c)＜min(b,d)であるかを判定すればいい。
*/

/*
    このコードで用いた方法は以下のようなもの
    [l,r] -> [l,r]
    [l,r) -> [l,r - 0.5]
    (l,r] -> [l + 0.5, r]
    (l,r) -> [l + 0.5, r - 0.5]

    この全て閉区間に直して共有部があるかを判定するものだと、
    ちょうど l と r が重なるときを注意しないといけない。
    そのときの数直線の単位の半分を足し引きすること

    このとき、判定は max(a, c) <= min(b, d);

*/

#include <bits/stdc++.h>
using namespace std;

using i64 = int64_t;
using ui64 = uint64_t;

int main() {
    int N;
    cin >> N;

    vector<i64> l(N), r(N);

    for(int i = 0; i < N; i++){
        int t;
        cin >> t;
        cin >> l.at(i) >> r.at(i);

        // 端点を含まない部分に数を足し引きする処理をしたいが、整数の範囲内に収めたいので2倍する
        // 数直線の単位を 2 ((単位)*2) にするイメージ
        // すべての座標を2倍にしても含有関係には影響しない
        l.at(i) *= 2;
        r.at(i) *= 2;

        if(t == 3 || t == 4){
            l.at(i)++;
        }
        if(t == 2 || t == 4){
            r.at(i)--;
        }
    }

    // debug
    /*
    for(int i = 0; i < N; i++){
        cout << "i = " << i << " " << endl;
        cout << "(l,r) = " << l.at(i) << ", " << r.at(i) << endl;
    }
    */

    i64 ans = 0;
    for(int i = 0; i < N; i++){
        for(int j = i + 1; j < N; j++){

            // 共有部分があるか。条件に等号を含むことに注意
            if(max(l.at(i), l.at(j)) <= min(r.at(i), r.at(j))){
                ans++;
            }

        }
    }

    cout << ans << endl;
}